---
title: "Parallel for Oregon Zip and WRF_Grid Intersection Proportion"
author: "Jingyang Liu"
date: "March 23, 2017"
output: slidy_presentation
---

```{r librarysetup, include=FALSE}
library(rgdal) # package for shape files
library(sp)
library(rgeos) # rgeos package contains the intersect and area commands I need
library(dplyr)
library(data.table)
library(readxl)
# parallel computing libraries
# library(foreach) 
library(doParallel)
library(parallel)
library(readr)
```

```{r shapefile prepare, include=FALSE}
## Imoport WRF Grid file of Oregon
setwd("C:/Users/jyliu/Desktop/local_git_repo/oregon_wildfire")
grid_dir <- paste0('./shapefile/oregon_grid.shp')
smoke_grid <- readOGR(dsn = grid_dir, layer = 'oregon_grid') # wrf_grid

## Import U.S. shapefile
shp_dir <- paste0('./shapefile/tl_2013_us_zcta510/tl_2013_us_zcta510.shp')
us_zip_2013 <- readOGR(dsn = shp_dir, layer = 'tl_2013_us_zcta510')

## Filter the U.S. shapefile only to Oregon State Zip Code
read_path2 <- paste0('C:/Users/jyliu/Desktop/local_git_repo/oregon_wildfire/', 
                     'oregon_zipcode.csv')
or_zip <- read_csv(read_path2)
names(or_zip) <- c('zip','type','city','county','area')
or_zip_map <- us_zip_2013[us_zip_2013$ZCTA5CE10 %in% or_zip$zip,]
or_zip <- as.character(sort(or_zip_map@data$ZCTA5CE10))

nad83 <- '+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0'
proj4string(smoke_grid) <- nad83
```


## Shapefile preparation: 2013 Oregon Zip code Shapefile and WRF Grid

Some libraries for spatial data analysis and parallel computing:
```{r, eval = FALSE}
library(rgdal)     # package for shape files
library(sp)        # spatial polygon
library(rgeos)     # rgeos package contains the intersect and area commands
library(parallel)  # parallel computing libraries
```


The **shapefile of Oregon** can be subset from the whole U.S. shapefile by filtering the zip code in Oregon State.

<br/>The **whole U.S shapefile** can be found from United States Census website:
<br/>https://www.census.gov/cgi-bin/geo/shapefiles/index.php?year=2013&layergroup=ZIP+Code+Tabulation+Areas

<br/>The **Oregon zip code** can also be found from: 
<br/>https://www.unitedstateszipcodes.org/or/

The plot below shows an Oregon State shapefile and an overlay of projected WRF Grid and Oregon shapefile.
```{r overlay, echo=FALSE}
plot(or_zip_map)
plot(smoke_grid)
plot(or_zip_map, add=T)
```



## Steps of calculating the proportion of intersection of a specific zip code polygon and WRF Grid.
1. Choose a zip code (94705 here) for testing. WRF Grid = 261 and 262. (6 WRF 
Grids in total. Only two are chosen for convenience)
```{r test, warning= FALSE, echo=FALSE}
test_zip <- c(97405)
test_zip_map <- or_zip_map[or_zip_map$ZCTA5CE10 %in% test_zip,]

plot(test_zip_map)
plot(smoke_grid, add = T)
invisible(text(getSpPPolygonsLabptSlots(smoke_grid), 
               labels=as.character(smoke_grid$WRFGRID_ID)))

```


2. The actual location in the map.
```{r, echo=FALSE}
# test zip map over zip grid
plot(smoke_grid)
plot(test_zip_map, add = T)
zip_over_grid <- over(test_zip_map, smoke_grid)
# summary(zip_over_grid) # this way retains the values
```


```{r include = FALSE}
# test_zip <- c(97405)
# test_zip_map <- or_zip_map[or_zip_map$ZCTA5CE10 %in% test_zip,]

# plot(test_zip_map)
# plot(smoke_grid, add = T)
# invisible(text(getSpPPolygonsLabptSlots(smoke_grid), 
#                labels=as.character(smoke_grid$WRFGRID_ID)))


shape_zip <- SpatialPolygons(test_zip_map@polygons)
shape_grid <- SpatialPolygons(smoke_grid@polygons)
plot(shape_zip)
plot(shape_grid, add = T)
# try and plot the values for this zipcode
invisible(text(getSpPPolygonsLabptSlots(smoke_grid), 
               labels=as.character(smoke_grid$WRFGRID_ID))) # grid width wider than previous map
```

```{r include = FALSE}
# output the WRF Grid 261 and 262 for test
wrf_grid_261 <- smoke_grid[smoke_grid@data$WRFGRID_ID == 261, ]
plot(wrf_grid_261)

wrf_grid_262 <- smoke_grid[smoke_grid@data$WRFGRID_ID == 262, ]
plot(wrf_grid_262)
```


```{r include = FALSE}
# calculate the area of grid 261 and 262
gArea(SpatialPolygons(wrf_grid_261@polygons))
gArea(SpatialPolygons(wrf_grid_262@polygons))
```


## Steps (Continued)
3. Show the intersection of chosen WRF Grid and zip code.
```{r show, warning=FALSE, echo=FALSE}
# Subset to one zip code and two different WRF grids ---------------------------
# plot zip and 2 grids
plot(test_zip_map)
#invisible(text(getSpPPolygonsLabptSlots(test_zip_map), 
#               labels=as.character(test_zip_map$ZCTA5CE10)))
plot(wrf_grid_261, add = T)
invisible(text(getSpPPolygonsLabptSlots(wrf_grid_261), 
               labels=as.character(wrf_grid_261$WRFGRID_ID)))
plot(wrf_grid_262, add=T)
invisible(text(getSpPPolygonsLabptSlots(wrf_grid_262), 
               labels=as.character(wrf_grid_262$WRFGRID_ID)))
```


4. The proportion of two WRF Grid.
```{r calculation, warning=FALSE, echo=FALSE}
# Start with the intersection with wrf grid 261 and zipcode
# first I need to convert the spatial polygon to just polygon
poly_261 <- SpatialPolygons(wrf_grid_261@polygons)
shape_zip <- SpatialPolygons(test_zip_map@polygons)

zip_261_int <- gIntersection(poly_261, shape_zip)
plot(zip_261_int)
plot(wrf_grid_261, add = T)
invisible(text(getSpPPolygonsLabptSlots(wrf_grid_261), 
               labels=as.character(wrf_grid_261$WRFGRID_ID)))

prop_261_int <- gArea(zip_261_int)/gArea(poly_261)
prop_261_int # 41.8% of grid is covered by zip

# now what about grid 262
poly_262 <- SpatialPolygons(wrf_grid_262@polygons)
shape_zip <- SpatialPolygons(test_zip_map@polygons)

zip_262_int <- gIntersection(poly_262, shape_zip)

plot(zip_262_int)
plot(wrf_grid_262, add = T)
invisible(text(getSpPPolygonsLabptSlots(wrf_grid_261), 
               labels=as.character(wrf_grid_261$WRFGRID_ID)))

prop_int_262 <- gArea(zip_262_int)/gArea(poly_262)
prop_int_262 # 6.0% of grid is covered by zip
```


## Why using for loop?

<ul class="incremental"> 
  <li> One choice: <br/>  simple calculation; copy and paste codes.</li> 
  <li> Another choice: for loop
  <br/> When analyzing big data set (for this data set, there are 417 zip codes 
  and 1610 WRF Grids in total), it is unrealistic to copy so many rows 
  (417*1610 = 671,370 times) of similar or same code.</li><br/>
  <li> And... <br/> Why using apply function? </li>
  <li> **Working Efficiency** <br/> **Vectorization.** Faster than for loop. It 
  works on margins of an array or matrix, not like for loop.</li> 
  <li> **Code Readability** <br/>  Understand the purporse more directly.</li> 
</ul> 




## Apply Family
>- Returns a vector or array or list of values obtained by applying a function to 
margins of an array or matrix.

>- The apply() Function
<br/> Apply functions over array margins.<br/>

>- The lapply() Function
<br/> Apply a function over a list or vector.<br/> 
Apply a given function to every element of a list and obtain a list as result.<br/>

>- The sapply() Function
<br/> Apply a function over a list or vector.<br/>
Works like lapply(), but it tries to simplify the output to the most elementary data structure that is possible. 

>- The tapply() Function
<br/> Apply a function over a ragged array.

>- The mapply() Function
<br/> Apply a function to multiple list or vector arguments.









