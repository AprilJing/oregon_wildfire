---
title: "Oregon: Zip-Level Wildfire Smoke and Health Outcomes (open in wildfire, not script)"
author: "Jingyang Liu"
date: "April 7, 2017"
output: html_document
---

## Overview

This document contains results for the association between wildfire smoke PM~2.5~ and cardiovascular (CVD) and respiratory health outcomes. This particular markdown document focuses on the zip code-level analysis. Herein, I compare different PM~2.5~ estimation methods described in further detail below. 

### Time-Stratified Case-Crossover (referents same day of week within fire season May - September)


```{r include=FALSE}
library(tidyverse)
library(data.table)
library(survival)
library(htmlTable)
library(readr)
```



```{r data import, include = F, eval = FALSE}

### Limit to only ER visits
## pos = 23
var_list <- c('respiratory', 'asthma', 'pneumonia',  'acute_bronch', 'copd', 
              'cvd', 'isch_heart_dis', 'arrhythmia', 'heart_failure', 
              'cerbrovas_dis', 'myocardial_infarc', 'broken_arm')

N <- NA
n <- 1

for (i in var_list){
  read_path <- paste('../data_new/update/ER/or', i, 'may_to_sep_time_strat_casecross.csv', sep = "_")
  or_disease <- read_csv(read_path)
  
  or_disease <- or_disease %>% 
    filter(pos=="23") %>%
    # filter the unknown gender
    filter(gender!= "U")
  
  # Create a permanent case-cross over dataset
  file_name <- paste('../data_new/update/ER/or', i, 'may_to_sep_time_strat_casecross_er.csv', sep = "_")
  
  # write permanent dataset
  write_csv(or_disease, paste0(file_name))
  N[n] = length(unique(or_disease$personkey))
  n = n+1
}


num_person <- data.frame(rbind(var_list, N))
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
## Analysis
path <- paste0("../data_new/update/ER")

resp_casecross <- read_csv(paste(path, 
                                 "or_respiratory_may_to_sep_time_strat_casecross_er.csv", 
                                 sep = "/"))

# asthma
asthma_casecross <- read_csv(paste(path, 
                                   "or_asthma_may_to_sep_time_strat_casecross_er.csv", 
                                   sep = "/")) 

# copd 
copd_casecross <- read_csv(paste(path, 
                                 "or_copd_may_to_sep_time_strat_casecross_er.csv", 
                                 sep = "/"))

# pneum or bronchitis
pneum_casecross <- read_csv(paste(path, 
                                  "or_pneumonia_may_to_sep_time_strat_casecross_er.csv",
                                  sep="/"))
 # acute bronchitis
acute_bronch_casecross <- read_csv(paste(path, 
                                         "or_acute_bronch_may_to_sep_time_strat_casecross_er.csv",
                                         sep = "/"))
# cvd
cvd_casecross <- read_csv(paste(path, 
                                "or_cvd_may_to_sep_time_strat_casecross_er.csv",
                                sep="/"))
# arrhythmia
arrhythmia_casecross <- read_csv(paste(path, 
                                       "or_arrhythmia_may_to_sep_time_strat_casecross_er.csv",
                                       sep="/"))
# cerebral vascular
cereb_vas_casecross <- read_csv(paste(path, 
                                      "or_cerbrovas_dis_may_to_sep_time_strat_casecross_er.csv",
                                      sep="/"))
# heart failure
hf_casecross <- read_csv(paste(path, 
                               "or_heart_failure_may_to_sep_time_strat_casecross_er.csv", 
                               sep="/"))
# ischemic heart disease
ihd_casecross <- read_csv(paste(path, 
                                "or_isch_heart_dis_may_to_sep_time_strat_casecross_er.csv",
                                sep="/"))
# myo infarc
mi_casecross <- read_csv(paste(path, 
                               "or_myocardial_infarc_may_to_sep_time_strat_casecross_er.csv", sep="/"))

# broken arm
broken_arm_casecross <- read_csv(paste(path, 
                                       "or_broken_arm_may_to_sep_time_strat_casecross_er.csv",
                                       sep="/"))

# read zip pm for counts by zip
smoke_path <- paste0("../data/Oregon/")
zip_pm <- read_csv(paste0(smoke_path, "zip_pm_to_merge_with_chars.csv"))
```


## Methods Description

In these comparisons, we examine various methods of smoke/PM~2.5~ estimations and associations with health outcomes using a time-stratified case-crossover study design. Health outcomes for a patient with a primary diagnosis of cardiopulmonary health outcomes and their date of admission  (index time) were identified. We then created counterfactual observations for each patient for the same day of the week for the entire wildfire season (MAy 1st to Sep 30th, 2013). We further limited our analyses to claims that were coded as emergency or urgent visits to eliminate bias from patients going in for elective/planned procedures. However, we found the filtered population is much larger than the population we chose in Washington, so we choose only the emegency room (hospital) visits. For patients who have a index time closer to May 1, 2013 or closer to September 30, 2013, their referent observations before or after these dates will be excluded as I will not be able to assign estimates of PM~2.5~ to these referent observations. However, this is not a big issue for a time-stratified design as other referent values throughout the time period average out.  

The **health outcomes** of interest are all respiratory, asthma, COPD, pneumonia, acute bronchitis, cardiovascular disease, heart failure, ischemic heart disease, and myocardial infarction. I also included broken arm, which I hypothesize to not be associated with wildfire smoke exposure and use as a check.

As for **exposure methods**, there are three main estimation methods for PM~2.5~: WRF-Chem Smoke (which substracts the WRF-Chem no fire emission from WRF-chem). For the WRF-Chem variable with the 'smoke' designator, this is WRF-Chem - WRF-Chem no fire. For Geo-Weighted Regression, and Kriging with 'smk' designator, I subtracted off the 'Background' estimates of smoke, which I believe are the monthly averages of PM~2.5~ for a given grid. However, the 'Background' is the mean of total period from May 1st to Sep 30th 2013 so I have to assign the mean for every day.

The **analytic method** is the conditional logistic regression model using the *survival* package in R. Each conditional logistic regression model accounts for the subject, and adjusts for temperature from the WRF-Chem model. The conditional logistic regression model \beta represents the change in risk of an event associated with a short-term unit increase in exposure, and can be calculated as an average difference between exposure at the index time and a weighted average of exposure at all times in the referent window. See Janes et al. 2005, **Statistics in Medicine**.

I've run a couple different scenarios for selecting referent periods, each of which has some paper that may justify the benefit of the design, relative to other methods.


## Population-Weighted PM~2.5~ Assigned by Zip Code

### Descriptives

For all of 2013, there were a total of millons of all claims records in the APAC dataset. During the May 1st to September 30th wildfire season in Oregon state, there were 47413 emergency visits for the specified cardiopulmonary codes. The number of persons (cases), as well as age-specific and sex-specific strate.

```{r descriptive table, echo = F, warning = F, results='asis'}

# dataframe list
df_list <- list(resp_casecross, asthma_casecross, copd_casecross, 
  pneum_casecross, acute_bronch_casecross, cvd_casecross, arrhythmia_casecross,
  cereb_vas_casecross, hf_casecross, ihd_casecross, mi_casecross, 
  broken_arm_casecross)

outcome_list <- c('All Respiratory', 'Asthma', 'COPD', 
                  'Pneumonia', 'Acute Bronchitis', 'Cardiovascular Disease',
                  'Arrhythmia', 'Cerebrovascular Disease', 'Heart Failure',
                  'Ischemic Heart Disease', 'Myocardial Infarction',
                  'Broken Arm')

method_list <- c('WRF-Chem Smoke', 'Geo-Weighted Smoke', 'Kriging Smoke')

# create an empty list to row bind dataframes together
datalist <- list()

# set list and do cross tabs to find values
# Producing conditional logit model estimates loop 
for(i in 1:length(df_list)){
# dataframe to loop through
  df_to_loop <- data.frame(df_list[i])
  # indication of column
  outcome <- colnames(df_to_loop[76])
  # outcome name
  outcome_name <- outcome_list[i]

  # dataframe for analysis creation
  # bind columns back together 
  df_analysis <- df_to_loop %>%
    # only look at outcomes
    filter(outcome == 1) %>%
    # add another row that makes sure there is a person <15 in the dataframe
    # tricking xtabs to produce a 0 cell for the outcome for age <15
    add_row(outcome = 0, age_ind = 0)
  
  # cross tabs
  outcome_n <- xtabs(~ outcome, df_analysis)
  cross_tab_age <- xtabs(~ outcome + age_ind, df_analysis)
  cross_tab_sex <- xtabs(~ outcome + sex_ind, df_analysis)
  # empty matrix
  point_estimates <- matrix(nrow = 1, ncol = 7, byrow = T)
  
  colnames(point_estimates) <- c("outcome", "n", "age_15", "age_15_65", 
                                 "age_65", "female", "male")
  
  # fill in the outcome name for the dataframe before the loop
  point_estimates[, 1] <- outcome_name
  # fill n
  point_estimates[, 2] <- outcome_n[2] # second element of the 1 dimension vector
  # age <15
  point_estimates[, 3] <- cross_tab_age[2, 1]
  # age 15 to 65
  point_estimates[, 4] <- cross_tab_age[2, 2]
  # age >65
  point_estimates[, 5] <- cross_tab_age[2, 3]
  # male == 0
  point_estimates[, 7] <- cross_tab_sex[1, 1]
  # female == 1
  point_estimates[, 6] <- cross_tab_sex[1, 2]


  # save point estimates as a dataframe
  point_est_df <- as_data_frame(point_estimates)
  
  # combine previous values in dataframe that has all outcome/methods comparisons
  datalist[[i]] <- point_est_df

} # end of loop

# combine each outcome dataframe itteration in to a big dataset
combined_point_est_df <- bind_rows(datalist) %>% 
  # find proportions/percents for each strata in a row
  mutate(age_15_pr = as.character(round((as.numeric(age_15)/as.numeric(n))*100,1)),
         age_15_65_pr = as.character(round((as.numeric(age_15_65)/as.numeric(n))*100,1)),
         age_65_pr = as.character(round((as.numeric(age_65)/as.numeric(n))*100,1)),
         female_pr = as.character(round((as.numeric(female)/as.numeric(n))*100,1)),
         male_pr = as.character(round((as.numeric(male)/as.numeric(n))*100,1))) %>% 
  select(outcome, n, age_15, age_15_pr, age_15_65, age_15_65_pr, age_65,
         age_65_pr, female, female_pr, male, male_pr)

#str(combined_point_est_df)
  
tab <- htmlTable(txtRound(combined_point_est_df, digits = 1), 
           caption = "Number of cases for each outcome observed from May 1st to September 30st, 2013",
           # column headers
           header = c("Outcome", "Cases n", "Less than 15", "(%)", "15 to 65", "(%)", "Greater than 65",
                      "(%)", "Female", "(%)", "Male", "(%)"),
           # column spanner
           cgroup = c("","Age Category", "Sex"), 
           n.cgroup = c(2, 6, 4),
           padding.rgroup = "&nbsp;&nbsp;",
           css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
           align = "llccccc" # column alignment,
            ) # end table

print(tab)

```




```{r echo = F, warning = F, results='asis'}

df_list <- list(resp_casecross, asthma_casecross, copd_casecross, 
                pneum_casecross, acute_bronch_casecross, cvd_casecross, arrhythmia_casecross,
                cereb_vas_casecross, hf_casecross, ihd_casecross, mi_casecross, 
                broken_arm_casecross)

outcome_list <- c('All Respiratory', 'Asthma', 'COPD', 
                  'Pneumonia', 'Acute Bronchitis', 'Cardiovascular Disease',
                  'Arrhythmia', 'Cerebrovascular Disease', 'Heart Failure',
                  'Ischemic Heart Disease', 'Myocardial Infarction',
                  'Broken Arm')

method_list <- c('WRF-Chem Smoke', 'Kriging Smoke', 'Geo-Weighted Smoke')

# create an empty list to row bind dataframes together
datalist <- list()

# data wrangling ----
# Producing conditional logit model estimates loop 
for(i in 1:length(df_list)){
  
  # dataframe to loop through
  df_to_loop <- data.frame(df_list[i])
  # indication of column
  outcome <- colnames(df_to_loop[76])
  # outcome name
  outcome_name <- outcome_list[i]
  
  # extract covariates from dataframe
  covariates_df <- df_to_loop[, c(1:26, 71, 74, 76:85)]
  
  # extract pm values and divide by 10 and ordered
  which(colnames(df_to_loop)=="background_pm_zip") # code to find column numbers, 91
  pm_estimates_df <- df_to_loop[, c(88, 93, 92, 94)]/10  # create 10 unit increases
  
  # dataframe for analysis creation
  # bind columns back together 
  df_analysis <- cbind(covariates_df, pm_estimates_df) %>% 
    # remove missing pm values
    filter(!is.na(wrf_smk_pm_zip)) %>% 
    
    # join in cdc met data
    # full_join(daily_zip_met, by = c("ZIPCODE", "date")) %>% 
    # the following code makes sure that the counterfactual values retained are 
    # symetric in that number of obs before = number of obs after
    mutate(obs_diff_admission = (fromdate - date)/7) 
  # dataframe is already for the entire fire season, so I don't need to subset anymore
  
  
  # empty df for table
  table_df <- data.frame()
  
  # empty matrix
  point_estimates <- matrix(nrow = 3, ncol = 9, byrow = T)
  
  colnames(point_estimates) <- c('outcome', 'pm_method', 'n', 'n_events', 'odds_ratio', 
                                 'lower95', 'upper95', 'se', 'p_val')
  
  # fill in the outcome name for the dataframe before the loop
  point_estimates[, 1] <- outcome_name
  
  
  # second loop to run a model for each pm estimation method
  for(j in 39:41){
    
    # variable to model 
    var_name <- colnames(df_analysis[j])
    
    # conditional logistic regression model
    mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
    
    # some model/DAG checks of data rish provided
    
    #glimpse(df_analysis)
    
    # adjusting for admit month is not possible as it's the same var for the subject.
    # adjusting for month smoke is a collider and should not be adjusted for.
    #summary(clogit(outcome ~ geo_smk_pm_zip + daily_meanRH + daily_meanT + daily_meanWS + daily_meanPrcp +
    #                as.factor(month_smk) + strata(PATIENTID), df_analysis))
    #outocme association: daily_meanRH, 
    
    # check for confoudning following DAG assumptions
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    # smoke predictor association: daily_meanRH, 
    #summary(lmer(geo_smk_pm_zip ~ daily_meanWS + (1 | PATIENTID), df_analysis ))
    #summary(lmer(wrf_temp_zip ~ daily_meanT + (1 | PATIENTID), df_analysis ))
    #cor(df_analysis$wrf_temp_county, df_analysis$daily_meanT)
    
    
    # populate matrix
    row_n <- j-38
    
    point_estimates[row_n, 2] <- method_list[row_n]
    point_estimates[row_n, 3] <- mod$n
    point_estimates[row_n, 4] <- mod$nevent
    # odds ratio
    point_estimates[row_n, 5] <- round(exp(summary(mod)$coefficient[1,1]), 3)
    
    # 95% lower bound
    point_estimates[row_n, 6] <- round(exp((summary(mod)$coefficient[1,1]) -
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # 95% upper bound
    point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) +
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # standard error
    point_estimates[row_n, 8] <- round(summary(mod)$coefficient[1,3], 4)
    # p val
    point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,5], 4)
    
    # save point estimates as a dataframe
    point_est_df <- as_data_frame(point_estimates)
    
  }
  
  # combine previous values in dataframe that has all outcome/methods comparisons
  datalist[[i]] <- point_est_df
  
} # end of loop

# combine each outcome dataframe itteration in to a big dataset
combined_point_est_df <- bind_rows(datalist)


# subset columns I want to put in to the table
table_df <- combined_point_est_df %>% select(2, 3:7) 



tab <- htmlTable(txtRound(table_df, digits = 3, 1:3), 
                 caption = "Association between a 10 ug/m^3 in PM2.5 and Health Outcomes",
                 # row group by outcome
                 rgroup = outcome_list,
                 n.rgroup = c(rep(3, 12)), # 4 rows for each method for each outcome
                 # column headers
                 header = c("Method", "Obs.", "Events",
                            "OR&dagger;", "Lower", "Upper"),
                 # column spanner
                 cgroup = c("", "95% CI"), 
                 n.cgroup = c(4, 2),
                 padding.rgroup = "&nbsp;&nbsp;",
                 css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
                 align = "llccccc", # column alignment,
                 tfoot="&dagger; Adjusted for CDC temperature, relatively humidity, wind speed, and precipitation; accounting for subject. Time-stratified: referent periods matched to events on same day of week within July to October fire season."
) # end table

print(tab)

# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
combined_point_est_df$outcome <- factor(combined_point_est_df$outcome, 
                                        levels = unique(combined_point_est_df$outcome))

combined_point_est_df$pm_method <- factor(combined_point_est_df$pm_method, 
                                          levels = unique(combined_point_est_df$pm_method))

combined_point_est_df$n <- as.numeric(combined_point_est_df$n)
combined_point_est_df$n_events <- as.numeric(combined_point_est_df$n_events)
combined_point_est_df$odds_ratio <- as.numeric(combined_point_est_df$odds_ratio)
combined_point_est_df$lower95 <- as.numeric(combined_point_est_df$lower95)
combined_point_est_df$upper95 <- as.numeric(combined_point_est_df$upper95)
combined_point_est_df$se <- as.numeric(combined_point_est_df$se)
combined_point_est_df$p_val <- as.numeric(combined_point_est_df$p_val)

# subset out global method
combined_point_est_df <- combined_point_est_df


## ggplot
print_plot <- ggplot(combined_point_est_df, 
                     aes(x = pm_method, y = odds_ratio, colour = pm_method)) +
  # custom color 
  scale_color_manual(name = "Smoke-Estimation Method", 
                     values = c("red", "blue", "#32115C"),
                     guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
  geom_point() + #geom_text(vjust = 0, nudge_x = 0.3) +
  geom_errorbar(aes(ymin=lower95, ymax=upper95), width = 0.2) +
  facet_wrap(~outcome, nrow = 3) +
  geom_hline(yintercept = 1, linetype=2) +
  #    ggtitle('Association Between PM2.5 \n from Wildfire Smoke on Hospitalizations') +
  ylab(expression(paste("Odds Ratio for 10µg/m"^3, " Increase in PM"[2.5]))) +
  #xlab('Smoke Estimation Method') +
  # plot theme
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        # strip element
        strip.background = element_rect(colour=NA, fill=NA),
        panel.border = element_rect(fill = NA, color = "black"),
        # facet text size
        #strip.text = element_text(size = 8),
        # axis element
        axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(angle = 90),
        # legend elements
        legend.position = "bottom")
#legend.text = element_text(size = 8))

print(print_plot)
# save figure
ggsave("./fig_only_er.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")
```





### Time-Stratified by Age Categories 

Following table and figure look at some outcomes stratified by age category. Note that kids <=15 likely won't have many outcomes like COPD or MI. I have restricted the dataset to just the geo smoke method to reduce the number of rows/points on the tables and figures to make it easier to read for now. Code can easily be changed to have all PM~2.5~ methods.

For some outcomes, there may be some evidence of effect modificaiton, like COPD, where >65 age group is at significant risk. However, the point estimates are relatively similar for the 15 to 65 strata, just not significant. Some error bars are not shown as they are too wide; usually <15 age category where there are only a handful of outcomes.


```{r time stratified age strata cdc met, warning =F, echo = F, results='asis'} 
# note above, results = 'asis' needed to print htmlTables

# For age categories, I want a loop for each age category. 
# Presenting just WRF and GWR

# dataframe list
df_list <- list(resp_casecross, asthma_casecross, copd_casecross, pneum_casecross,
                acute_bronch_casecross, cvd_casecross, arrhythmia_casecross,
                cereb_vas_casecross, hf_casecross, ihd_casecross, mi_casecross, 
                broken_arm_casecross)

outcome_list <- c('All Respiratory', 'Asthma', 'COPD', 'Pneumonia', 
                  'Acute Bronchitis', 'Cardiovascular Disease', 'Arrhythmia', 
                  'Cerebrovascular Disease', 'Heart Failure',
                  'Ischemic Heart Disease', 'Myocardial Infarction', 'Broken Arm')

# looking only at wrf chem, kriging, and geo-weighted; taking out 'Global Smoke' method
method_list <- c('WRF-Chem Smoke', 'Kriging Smoke', 'GWR Smoke')

# age category list
age_cat_list <- c(0,1,2)

# create an empty list to row bind dataframes together
datalist1 <- list()
datalist2 <- list()

var_list <- c('respiratory', 'asthma', 'pneumonia',  'acute_bronch', 'copd', 
              'cvd', 'isch_heart_dis', 'arrhythmia', 'heart_failure', 
              'cerbrovas_dis', 'myocardial_infarc', 'broken_arm')


# data wrangling ----
# Producing conditional logit model estimates loop 
for(i in 1:length(df_list)){

# dataframe to loop through
  df_to_loop <- data.frame(df_list[i])
  # indication of column
  outcome <- var_list[i]
  # outcome name
  outcome_name <- outcome_list[i]

  # extract covariates from dataframe
  covariates_df <- df_to_loop[, c(1:26, 71, 74, 76:85)]
  
  # extract pm values and divide by 10 and ordered
  #which(colnames(df_to_loop)=="global_smk_pm_zip") # code to find column numbers
  pm_estimates_df <- df_to_loop[, c(88, 93, 92, 94)]/10  # create 10 unit increases

  # new loop for age categories
  for(k in 0:2){
    
    # empty matrix (12 x 10 matrix)
    point_estimates <- matrix(nrow = 3, ncol = 10, byrow = T)
    
    colnames(point_estimates) <- c('outcome', 'age_cat', 'pm_method', 'n', 'n_events', 
                                   'odds_ratio', 'lower95', 'upper95', 'se', 'p_val')
    
    # fill in the outcome namedataframe before method loop
    point_estimates[, 1] <- outcome_name
    # repeat the age category 4 times for each pm method
    point_estimates[, 2] <- k
    
    # dataframe for analysis creation
    # bind columns back together 
    df_analysis <- cbind(covariates_df, pm_estimates_df) %>% 
      # remove missing pm values
      filter(!is.na(wrf_smk_pm_zip)) %>% 
      # limit to specific age category
      filter(age_ind == k) %>% 
      # the following code makes sure that the counterfactual values retained are 
      # symetric in that number of obs before = number of obs after
      mutate(obs_diff_admission = (fromdate - date)/7) 
      # dataframe is already for the entire fire season, so I don't need to subset anymore
    

  # second loop to run a model for each pm estimation method
    for(j in 39:41){

      # variable to model 
      var_name <- colnames(df_analysis[j])
      
      # set row number to fill
      row_n <- j-38
      
      # only run the model if the dataframe has observations
      if(nrow(df_analysis) != 0){
      # conditional logistic regression model
      mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
      
      # populate matrix
      point_estimates[row_n, 3] <- method_list[row_n]
      point_estimates[row_n, 4] <- mod$n
      point_estimates[row_n, 5] <- mod$nevent
      # odds ratio
      point_estimates[row_n, 6] <- round(exp(summary(mod)$coefficient[1,1]), 3)

      # 95% lower bound
      point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) -
                                        1.96*(summary(mod)$coefficient[1,3])), 3)
      # 95% upper bound
      point_estimates[row_n, 8] <- round(exp((summary(mod)$coefficient[1,1]) +
                                        1.96*(summary(mod)$coefficient[1,3])), 3)
      # standard error
      point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,3], 4)
      # p val
      point_estimates[row_n, 10] <- round(summary(mod)$coefficient[1,5], 4)
      
      # create else statement that fills matrix with missing so I still have the row
      # in the final dataframe
      } else {point_estimates[row_n, 3] <- method_list[row_n]
              point_estimates[row_n, 4] <- 0
              point_estimates[row_n, 5] <- 0
              point_estimates[row_n, c(6:10)] <- 99 } # end 'if else' statement

    } # end methods loop
  
    # save point estimates as a dataframe
    point_est_df <- as_data_frame(point_estimates)
    
    # combine previous values in dataframe that has all outcome/methods comparisons
    datalist1[[k+1]] <- point_est_df
  } # end age category loop

  # bind rows of age category estimates together
 age_est_df <- bind_rows(datalist1)
 
 # populate second dataframe list
 datalist2[[i]] <- age_est_df

} # end of outcome loop

# combine each outcome dataframe itteration in to a big dataset
combined_point_est_df <- bind_rows(datalist2)

wrf_geo_age <- combined_point_est_df %>% 
  # filter columns to just geo-smk
  filter(pm_method == "GWR Smoke" |
         pm_method == "WRF-Chem Smoke") %>% 
  mutate(age_cat2 = ifelse(age_cat == 0, "Less than 15", 
                    ifelse(age_cat == 1, "15-65",
                    ifelse(age_cat == 2, "Greater than 65", NA)))) %>% 
  # subset columns I want to put in to the table
  select(3, 11, 5:8) %>% 
  mutate(odds_ratio = ifelse(odds_ratio == 99, "--", odds_ratio),
         lower95 = ifelse(lower95 == 99, "--", lower95),
         upper95 = ifelse(upper95 == 99, "--", upper95))


  tab <- htmlTable(txtRound(wrf_geo_age, digits = 3, 1:3), 
           caption = "Association between a 10 ug/m^3 in PM2.5 geo smoke and health outcomes stratified by age",
           # row group by outcome
           rgroup = outcome_list,
           n.rgroup = c(rep(6, 12)), # 6 rows for each age cat for each outcome
           # column headers
           header = c("Est Method", "Age Group", "Events",
                      "OR&dagger;", "Lower", "Upper"),
           # column spanner
           cgroup = c("", "95% CI"), 
           n.cgroup = c(4, 2),
           padding.rgroup = "&nbsp;&nbsp;",
           css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
           align = "llcccc", # column alignment,
           tfoot="&dagger; Adjusted for CDC temperature, wind speed, relative humidity, precipitation, and accounting for subject. Time-stratified: referent periods matched to events on same day of week within July to October fire season."
            ) # end table
  
  print(tab)
  


# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
wrf_geo_age_plot <- combined_point_est_df %>% 
  # filter columns to just geo-smk
  filter(pm_method == "GWR Smoke" | pm_method == "WRF-Chem Smoke") %>% 
  # do not plot results with less than 15 events, create missing vals
  # in mutate
  mutate(odds_ratio = ifelse(as.numeric(n_events) < 15, 
                             99, odds_ratio),
         lower95 = ifelse(as.numeric(n_events) < 15, 
                             99, lower95),
         upper95 = ifelse(as.numeric(n_events) < 15, 
                             99, upper95),
         age_cat2 = ifelse(age_cat == 0, "<15", 
                    ifelse(age_cat == 1, "15-65",
                    ifelse(age_cat == 2, ">65", NA)))) %>% 
  # subset columns I want to put in to the table
  select(1, 3, 11, 5:8) %>% 
  mutate(odds_ratio = ifelse(odds_ratio == 99, NA, odds_ratio),
         lower95 = ifelse(lower95 == 99, NA, lower95),
         upper95 = ifelse(upper95 == 99, NA, upper95))

# change characters to numeric and factor  
wrf_geo_age_plot$outcome <- factor(wrf_geo_age_plot$outcome,
                              levels = unique(wrf_geo_age_plot$outcome))

wrf_geo_age_plot$pm_method <- factor(wrf_geo_age_plot$pm_method,
                                levels = unique(wrf_geo_age_plot$pm_method))

wrf_geo_age_plot$age_cat2 <- factor(wrf_geo_age_plot$age_cat2,
                                levels = unique(wrf_geo_age_plot$age_cat2))

wrf_geo_age_plot$n_events <- as.numeric(wrf_geo_age_plot$n_events)
wrf_geo_age_plot$odds_ratio <- as.numeric(wrf_geo_age_plot$odds_ratio)
wrf_geo_age_plot$lower95 <- as.numeric(wrf_geo_age_plot$lower95)
wrf_geo_age_plot$upper95 <- as.numeric(wrf_geo_age_plot$upper95)


## ggplot 
  print_plot <- ggplot(wrf_geo_age_plot,
    aes(x = age_cat2, y = odds_ratio, color = pm_method), na.rm = T) +
    geom_point(position = position_dodge(width = 0.5), na.rm = T) + 
    geom_errorbar(aes(ymin=lower95, ymax=upper95), 
                  position = position_dodge(width = 0.5), width = 0.2, na.rm =T) +
    # custom color 
    scale_color_manual(name = "Smoke-Estimation Method", 
                       values = c("red", "#32115C"),
                       guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
    facet_wrap(~outcome, nrow = 3, scales = "free") +
    geom_hline(yintercept = 1, linetype=2) +
    #ggtitle('Association Between PM2.5 from \n Wildfire Smoke on Hospitalizations') +
    ylab(expression(paste("Odds Ratio for 10µg/m"^3, " Increase in PM"[2.5]))) +
    #ylim(0, 2) +
    xlab('Age Category ') +
    # plot theme
    theme(panel.background = element_rect(fill = 'white', colour = 'black'),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    # strip element
    strip.background = element_rect(colour=NA, fill=NA),
    panel.border = element_rect(fill = NA, color = "black"),
    # facet text size
    strip.text = element_text(size = 10),
    # axis element
    #axis.text.x = element_blank(),
    #axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.y = element_text(angle = 90),
    # legend elements
    legend.position = "bottom")
    #legend.text = element_text(size = 8))


  print(print_plot)
  # save figure
  ggsave("./age_fig.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")
  
  
```



### Seasonal Time-Stratified by Sex

Association with smoke PM~2.5~ and health outcomes stratified by sex. May be some evidence of effect modification by sex, particularly where males appear to be at greater risk for certain CVD outcomes with increasing smoke. However, only marginally significant. Also, broken arm estimate seems a little strange, suggesting females at greater risk too. Larger sample size may help to answer this.

```{r sex strata cdc met adj, warning = F, echo = F, results='asis'} 
# note above, results = 'asis' needed to print htmlTables

# For age categories, I want a loop for each age category. 


# dataframe list
df_list <- list(resp_casecross, asthma_casecross, copd_casecross, pneum_casecross,
                acute_bronch_casecross, cvd_casecross, arrhythmia_casecross,
                cereb_vas_casecross, hf_casecross, ihd_casecross, mi_casecross, 
                broken_arm_casecross)

outcome_list <- c('All Respiratory', 'Asthma', 'COPD', 'Pneumonia', 
                  'Acute Bronchitis', 'Cardiovascular Disease', 'Arrhythmia', 
                  'Cerebrovascular Disease', 'Heart Failure',
                  'Ischemic Heart Disease', 'Myocardial Infarction', 'Broken Arm')

# looking only at wrf chem, kriging, and geo-weighted; taking out 'Global Smoke' method
method_list <- c('WRF-Chem Smoke', 'Kriging Smoke', 'GWR Smoke')

# sex category list
sex_strata_list <- c(0,1)

# create an empty list to row bind dataframes together
datalist1 <- list()
datalist2 <- list()

# data wrangling ----
# Producing conditional logit model estimates loop 
for(i in 1:length(df_list)){
  
  # dataframe to loop through
  df_to_loop <- data.frame(df_list[i])
  # indication of column
  outcome <- var_list[i]
  # outcome name
  outcome_name <- outcome_list[i]

  # extract covariates from dataframe
  covariates_df <- df_to_loop[, c(1:26, 71, 74, 76:85)]
  
  # extract pm values and divide by 10 and ordered
  #which(colnames(df_to_loop)=="global_smk_pm_zip") # code to find column numbers
  pm_estimates_df <- df_to_loop[, c(88, 93, 92, 94)]/10  # create 10 unit increases


  # new loop for sex categories
  for(k in 0:1){
 
    # empty matrix (12 x 10 matrix)
    point_estimates <- matrix(nrow = 3, ncol = 10, byrow = T)
    
    colnames(point_estimates) <- c('outcome', 'sex', 'pm_method', 'n', 'n_events', 
                                   'odds_ratio', 'lower95', 'upper95', 'se', 'p_val')
    
    # fill in the outcome namedataframe before method loop
    point_estimates[, 1] <- outcome_name
    # repeat the sex category 4 times for each pm method
    point_estimates[, 2] <- k
    
    
    # dataframe for analysis creation
    # bind columns back together 
    df_analysis <- cbind(covariates_df, pm_estimates_df) %>% 
      # remove missing pm values
      filter(!is.na(wrf_smk_pm_zip)) %>% 
      # limit to specific sex category
      filter(sex_ind == k) %>% 
      # the following code makes sure that the counterfactual values retained are 
      # symetric in that number of obs before = number of obs after
      mutate(obs_diff_admission = (fromdate - date)/7) 
      # dataframe is already for the entire fire season, so I don't need to subset anymore

  # second loop to run a model for each pm estimation method
    for(j in 39:41){

      # variable to model 
      var_name <- colnames(df_analysis[j])
      
      # set row number to fill
      row_n <- j-38
      
      # only run the model if the dataframe has observations
      if(nrow(df_analysis) != 0){
      # conditional logistic regression model
      mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
      
      # populate matrix
      point_estimates[row_n, 3] <- method_list[row_n]
      point_estimates[row_n, 4] <- mod$n
      point_estimates[row_n, 5] <- mod$nevent
      # odds ratio
      point_estimates[row_n, 6] <- round(exp(summary(mod)$coefficient[1,1]), 3)

      # 95% lower bound
      point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) -
                                        1.96*(summary(mod)$coefficient[1,3])), 3)
      # 95% upper bound
      point_estimates[row_n, 8] <- round(exp((summary(mod)$coefficient[1,1]) +
                                        1.96*(summary(mod)$coefficient[1,3])), 3)
      # standard error
      point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,3], 4)
      # p val
      point_estimates[row_n, 10] <- round(summary(mod)$coefficient[1,5], 4)
      
      # create else statement that fills matrix with missing so I still have the row
      # in the final dataframe
      } else {point_estimates[row_n, 3] <- method_list[row_n]
              point_estimates[row_n, 4] <- 0
              point_estimates[row_n, 5] <- 0
              point_estimates[row_n, c(6:10)] <- 99 } # end 'if else' statement

    } # end methods loop
  
    # save point estimates as a dataframe
    point_est_df <- as_data_frame(point_estimates)
    
    # combine previous values in dataframe that has all outcome/methods comparisons
    datalist1[[k+1]] <- point_est_df
  } # end sex category loop

  # bind rows of sex category estimates together
 sex_est_df <- bind_rows(datalist1)
 
 # populate second dataframe list
 datalist2[[i]] <- sex_est_df

} # end of outcome loop

# combine each outcome dataframe itteration in to a big dataset
combined_point_est_df <- bind_rows(datalist2)

wrf_geo_sex <- combined_point_est_df %>% 
  # filter columns to just geo-smk
  filter(pm_method == "GWR Smoke" | pm_method == "WRF-Chem Smoke") %>% 
  mutate(sex_cat = ifelse(sex == 0, "Male", 
               ifelse(sex == 1, "Female", NA))) %>% 
  # subset columns I want to put in to the table
  select(3, 11, 5:8)%>% 
  mutate(odds_ratio = ifelse(odds_ratio == 99, "--", odds_ratio),
         lower95 = ifelse(lower95 == 99, "--", lower95),
         upper95 = ifelse(upper95 == 99, "--", upper95))


  tab <- htmlTable(txtRound(wrf_geo_sex, digits = 3, 1:3), 
           caption = "Association between a 10 ug/m^3 in PM2.5 geo smoke and health outcomes stratified by sex",
           # row group by outcome
           rgroup = outcome_list,
           n.rgroup = c(rep(4, 12)), # 2 rows for each sex strata for each outcome
           # column headers
           header = c("Est Method", "Sex Strata", "Events",
                      "OR&dagger;", "Lower", "Upper"),
           # column spanner
           cgroup = c("", "95% CI"), 
           n.cgroup = c(4, 2),
           padding.rgroup = "&nbsp;&nbsp;",
           css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
           align = "llcccc", # column alignment,
           tfoot="&dagger; Adjusted for temperature, accounting for subject. Time-stratified: referent periods matched to events on same day of week within July to October fire season."
            ) # end table
  
  print(tab)
 
# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
wrf_geo_sex_plot <- combined_point_est_df %>% 
  # filter columns to just geo-smk
  filter(pm_method == "GWR Smoke" | 
         pm_method == "WRF-Chem Smoke") %>% 
  mutate(sex_cat = ifelse(sex == 0, "Male", 
               ifelse(sex == 1, "Female", NA))) %>%
  # subset columns I want to put in to the table
  select(1, 3, 11, 5:8) %>% 
  mutate(odds_ratio = ifelse(odds_ratio == 99, NA, odds_ratio),
         lower95 = ifelse(lower95 == 99, NA, lower95),
         upper95 = ifelse(upper95 == 99, NA, upper95))  

# change characters to numeric and factor  
wrf_geo_sex_plot$outcome <- factor(wrf_geo_sex_plot$outcome,
                              levels = unique(wrf_geo_sex_plot$outcome))

wrf_geo_sex_plot$pm_method <- factor(wrf_geo_sex_plot$pm_method,
                                levels = unique(wrf_geo_sex_plot$pm_method))

wrf_geo_sex_plot$sex_cat <- factor(wrf_geo_sex_plot$sex_cat,
                                levels = unique(wrf_geo_sex_plot$sex_cat))

wrf_geo_sex_plot$n_events <- as.numeric(wrf_geo_sex_plot$n_events)
wrf_geo_sex_plot$odds_ratio <- as.numeric(wrf_geo_sex_plot$odds_ratio)
wrf_geo_sex_plot$lower95 <- as.numeric(wrf_geo_sex_plot$lower95)
wrf_geo_sex_plot$upper95 <- as.numeric(wrf_geo_sex_plot$upper95)


## ggplot
  print_plot <- ggplot(wrf_geo_sex_plot,
    aes(x = sex_cat, y = odds_ratio, color = pm_method), na.rm = T) +
    geom_point(position = position_dodge(width = 0.5), na.rm = T) + 
    geom_errorbar(aes(ymin=lower95, ymax=upper95), 
                  position = position_dodge(width = 0.5), width = 0.2, na.rm =T) +
    # custom color 
    scale_color_manual(name = "Smoke-Estimation Method", 
                       values = c("red", "#32115C"),
                       guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
    facet_wrap(~outcome, nrow = 3, scales = "free") +
    geom_hline(yintercept = 1, linetype=2) +
    #ggtitle('Association Between PM2.5 from \n Wildfire Smoke on Hospitalizations') +
    ylab(expression(paste("Odds Ratio for 10µg/m"^3, " Increase in PM"[2.5]))) +
    #ylim(0, 2) +
    xlab('Sex') +
    # plot theme
    theme(panel.background = element_rect(fill = 'white', colour = 'black'),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    # strip element
    strip.background = element_rect(colour=NA, fill=NA),
    panel.border = element_rect(fill = NA, color = "black"),
    # facet text size
    strip.text = element_text(size = 10),
    # axis element
    #axis.text.x = element_blank(),
    #axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.y = element_text(angle = 90),
    # legend elements
    legend.position = "bottom")
    #legend.text = element_text(size = 8))


  print(print_plot)
  # save figure
  ggsave("./sex_fig.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")


```





