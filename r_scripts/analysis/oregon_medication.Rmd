---
title: "Oregon 2013 Medication for Asthma"
author: "Jingyang Liu"
date: "May 17, 2017"
output: html_document
---

```{r library, include=FALSE, echo=FALSE}
library(dplyr)
library(data.table)
library(readxl) 
library(readr)
library(survival)
library(ggplot2)
library(htmlTable)
```

## Overview
For Oregon All Payer All Claims


Focus on GWR


## Data cleaning (Previous prepare work and code omitted)
I filter the observations in whole data set with only ndc (National Drug Code) exists. Also I limit the state to Oregon State. 

```{r import original data, eval=FALSE, echo=FALSE}
### Import whole data set ------------------------------------------------------
read_path <- paste0("../../../data/data_original/gan_episodes_of_care.txt")
start_time <- Sys.time()
oregon_df <- fread(read_path, sep = "|", showProgress = T) 
stop_time <-  Sys.time() - start_time 
# time it took
stop_time # 7 mins

## Basic cleaning
start_time <- Sys.time()
oregon_df2 <- oregon_df %>% 
  filter((!ndc=="")&(!ndc=="*NULL*")) %>% 
  # filter State is Oregon
  filter(STATE=="OR")
stop_time <-  Sys.time() - start_time 
# time it took
stop_time # 40 secs

write_path <- paste0('../../../data/data_new/',
                     'oregon_ndc.csv')
write_csv(oregon_df2, write_path)
```

### Choose ndc
This analysis researches on asthma medication of Oregon All Claims All Payers data set.

I choose the inhalation medicine beta 2 agonists to filter the sample for asthma.

```{r ndc, eval=FALSE, echo=FALSE}
### Import NDC data set --------------------------------------------------------
read_path <- paste0("../../../data/data_new/oregon_ndc.csv")
oregon_ndc <- read_csv(read_path)
dim(oregon_ndc) # 23330714 obs

which(oregon_ndc$ndc=="23490502001")

## Import Asthma NDC table
read_path2 <- paste0("../../../data/data_new/ndc_2013_beta_2_agonists.csv")
asthma_ndc <- read_csv(read_path2, col_names = FALSE)

colnames(asthma_ndc) <- c("ndc_code", "brand_name", "generic_product_name", 
                          "route", "category", "drug_id")

# convert to vector
ndc_codes <- as.vector(as.matrix(asthma_ndc$ndc_code))

oregon_asthma <- oregon_ndc %>%
  filter(ndc %in% ndc_codes) # 232665

# limit to the unique personkey different days' first visit
oregon_asthma_df <- oregon_asthma %>% 
  group_by(personkey) %>% 
  arrange(personkey, fromdate, line) %>% 
  mutate(num_visit = dense_rank(fromdate)) %>%
  arrange(personkey, num_visit) %>% 
  select(personkey, clmid, num_visit) %>% 
  unique() %>% 
  full_join(oregon_asthma, by = c("personkey", "clmid")) %>% 
  arrange(personkey, clmid, line, fromdate) %>% 
  filter(row_number() == 1) %>%
  # add new transverted from date
  mutate(dates = as.Date(fromdate, "%m/%d/%Y")) %>%
  filter(dates >= '2013-05-01' & 
         dates <= '2013-09-30') # 24538

write_path2 <- paste0("../../../data/data_new/oregon_asthma_ndc.csv")
write_csv(oregon_asthma_df, write_path2)

```

## Casecrossover study

I also make the "false" dates for each claim.

```{r casecrossover, eval=FALSE, echo=FALSE}
### Casecrossover study
read_path3 <- paste0("../../../data/data_new/medication/oregon_asthma_ndc.csv")
oregon_asthma_df <- read_csv(read_path3)


outcome_id <- oregon_asthma_df %>%
  # arrange with dates
  arrange(dates) %>%
  mutate(id = seq(1, nrow(.), by = 1))

# create dataset to populate
id_date_df <- data_frame()


# begin second loop to create counterfactual observations for each case subject
for (k in 1:nrow(outcome_id)){
  
  # find the replicate times of weeks
  dates_l <- outcome_id[[k,74]] 
  n1 <- 0
  d=as.Date("2013-05-01")
  i=1
  while (dates_l >= "2013-05-01"){
    dates_l <- dates_l - 7
    d[i] = dates_l
    i = i+1
    n1 = n1+1
  }
  d[1:n1-1] # shows character(0) when the first week
  n1-1
  
  dates_l <- outcome_id[[k,74]] 
  n2=0
  e=as.Date("2013-09-30")
  j=1
  while (dates_l <= "2013-09-30"){
    dates_l <- dates_l + 7
    e[j]=dates_l
    j=j+1
    n2 = n2 + 1
  }
  e[1:n2-1] # shows character(0) when the last week
  n2-1
  
  # replicate covariates length of counterfactual dates
  # and make conuterfactual dates
  if (n1==1){
    cov_df <- do.call("bind_rows", replicate(n1+n2-1, outcome_id[k,],simplify = F))
    cov_df$dates <- c(outcome_id[[k,74]], e[1:n2-1])
  } else if (n2==1){
    cov_df <- do.call("bind_rows", replicate(n1+n2-1, outcome_id[k,],simplify = F))
    cov_df$dates <- c(outcome_id[[k,74]], d[1:(n1-1)])
  }else{
    cov_df <- do.call("bind_rows", replicate(n1+n2-1, outcome_id[k,],simplify = F))
    cov_df$dates <- c(outcome_id[[k,74]], d[1:(n1-1)], e[1:n2-1])
  }
  
  # bind unique id and date of the year with covariates
  id_date <- bind_cols(cov_df)
  # iteration which binds rows of unique ids
  id_date_df <- bind_rows(id_date_df, id_date)
}

outcome_casecross <- id_date_df %>%
  mutate(outcome = ifelse(dates == as.Date(fromdate, "%m/%d/%Y"), 1, 0)) %>%
  arrange(id, dates) # order by id and date

outcome_casecross <- id_date_df %>%
  mutate(outcome = ifelse(dates == as.Date(fromdate, "%m/%d/%Y"), 1, 0)) %>%
  arrange(personkey, dates) # order by id and date

write_path2 <- paste0("../../../data/data_new/oregon_ndc_casecrossover.csv")
write_csv(outcome_casecross, write_path2)

```


## Time-Stratified Case-Crossover (referents same day of week within fire season May - September)

** The following analysis are done in local R.**

```{r time stratified, eval=FALSE, echo=FALSE}
### Time stratified ------------------------------------------------------------
# read in zipcode level populatoin-weighted pm
read_path5 <- paste0('C:/Users/jyliu/Desktop/local_git_repo/oregon_wildfire_new/data/Oregon_PM/zip_pm_to_merge_with_acap.csv')

zip_smoke <- read_csv(read_path5) # 63801 rows

# descriptives of the two smoke datasets
summary(zip_smoke)

# Zipcode PM2.5 estimates
# create lag variables that take smoke values from n previous days for zipcodes
zip_smoke_w_lag <- zip_smoke %>% arrange(ZIPCODE, date) %>%
  # group by zipcode
  group_by(ZIPCODE) %>% 
  # wrf
  mutate(wrf_f_pm_lag1 = lag(wrf_f_pm, 1, order_by = ZIPCODE), 
         wrf_f_pm_lag2 = lag(wrf_f_pm, 2, order_by = ZIPCODE),
         wrf_f_pm_lag3 = lag(wrf_f_pm, 3, order_by = ZIPCODE),
         wrf_f_pm_lag4 = lag(wrf_f_pm, 4, order_by = ZIPCODE),
         wrf_f_pm_lag5 = lag(wrf_f_pm, 5, order_by = ZIPCODE),
         # wrf no fire lag
         wrf_nf_pm_lag1 = lag(wrf_nf_pm, 1, order_by = ZIPCODE),
         wrf_nf_pm_lag2 = lag(wrf_nf_pm, 2, order_by = ZIPCODE),
         wrf_nf_pm_lag3 = lag(wrf_nf_pm, 3, order_by = ZIPCODE),
         wrf_nf_pm_lag4 = lag(wrf_nf_pm, 4, order_by = ZIPCODE),
         wrf_nf_pm_lag5 = lag(wrf_nf_pm, 5, order_by = ZIPCODE),
         # wrf_smk_pm
         wrf_smk_pm_lag1 = lag(wrf_smk_pm, 1, order_by = ZIPCODE),
         wrf_smk_pm_lag2 = lag(wrf_smk_pm, 2, order_by = ZIPCODE),
         wrf_smk_pm_lag3 = lag(wrf_smk_pm, 3, order_by = ZIPCODE),
         wrf_smk_pm_lag4 = lag(wrf_smk_pm, 4, order_by = ZIPCODE),
         wrf_smk_pm_lag5 = lag(wrf_smk_pm, 5, order_by = ZIPCODE),
         # geo weighted pm
         geo_wt_pm_lag1 = lag(geo_wt_pm, 1, order_by = ZIPCODE),
         geo_wt_pm_lag2 = lag(geo_wt_pm, 2, order_by = ZIPCODE),
         geo_wt_pm_lag3 = lag(geo_wt_pm, 3, order_by = ZIPCODE),
         geo_wt_pm_lag4 = lag(geo_wt_pm, 4, order_by = ZIPCODE),
         geo_wt_pm_lag5 = lag(geo_wt_pm, 5, order_by = ZIPCODE),
         # krig pm
         krig_pm_lag1 = lag(krig_pm, 1, order_by = ZIPCODE),
         krig_pm_lag2 = lag(krig_pm, 2, order_by = ZIPCODE),
         krig_pm_lag3 = lag(krig_pm, 3, order_by = ZIPCODE),
         krig_pm_lag4 = lag(krig_pm, 4, order_by = ZIPCODE),
         krig_pm_lag5 = lag(krig_pm, 5, order_by = ZIPCODE),   
         # background pm
         background_pm_lag1 = lag(background_pm, 1, order_by = ZIPCODE),
         background_pm_lag2 = lag(background_pm, 2, order_by = ZIPCODE),
         background_pm_lag3 = lag(background_pm, 3, order_by = ZIPCODE),
         background_pm_lag4 = lag(background_pm, 4, order_by = ZIPCODE),
         background_pm_lag5 = lag(background_pm, 5, order_by = ZIPCODE),   
         # geo_smk_pm 
         geo_smk_pm_lag1 = lag(geo_smk_pm, 1, order_by = ZIPCODE),
         geo_smk_pm_lag2 = lag(geo_smk_pm, 2, order_by = ZIPCODE),
         geo_smk_pm_lag3 = lag(geo_smk_pm, 3, order_by = ZIPCODE),
         geo_smk_pm_lag4 = lag(geo_smk_pm, 4, order_by = ZIPCODE),
         geo_smk_pm_lag5 = lag(geo_smk_pm, 5, order_by = ZIPCODE),
         # krig smk pm
         krig_smk_pm_lag1 = lag(krig_smk_pm, 1, order_by = ZIPCODE),
         krig_smk_pm_lag2 = lag(krig_smk_pm, 2, order_by = ZIPCODE),
         krig_smk_pm_lag3 = lag(krig_smk_pm, 3, order_by = ZIPCODE),
         krig_smk_pm_lag4 = lag(krig_smk_pm, 4, order_by = ZIPCODE),
         krig_smk_pm_lag5 = lag(krig_smk_pm, 5, order_by = ZIPCODE),
         # temp
         wrf_temp_lag1 = lag(wrf_temp, 1, order_by = ZIPCODE),
         wrf_temp_lag2 = lag(wrf_temp, 2, order_by = ZIPCODE),
         wrf_temp_lag3 = lag(wrf_temp, 3, order_by = ZIPCODE),
         wrf_temp_lag4 = lag(wrf_temp, 4, order_by = ZIPCODE),
         wrf_temp_lag5 = lag(wrf_temp, 5, order_by = ZIPCODE)) %>% 
  # ungroup by zip
  ungroup(ZIPCODE) %>% 
  # attach a zip indicator for each smoke variable
  setNames(paste(colnames(.), "zip", sep="_")) %>% 
  # remove the '_zip' from the zipcode and date variable 
  rename(ZIPCODE = ZIPCODE_zip, date = date_zip)


read_path4 <- paste0("../data_new/medication/oregon_ndc_casecrossover.csv")
# read_path4 <- paste0("../../../data/data_new/oregon_ndc_casecrossover.csv") # for server
or_disease <- read_csv(read_path4)

### try join
colnames(or_disease)[24] <- c("ZIPCODE")
colnames(or_disease)[74] <- c("date")

outcome_casecross <- or_disease %>%
  # indicator for male=0, female=1, unknown = 2
  mutate(age = 2013-yob,
         sex_ind =ifelse(gender == "F", 1, 
                         ifelse(gender == "M", 0, 2)),
         age_ind = ifelse(age < 15, 0,
                          ifelse(age >= 15 & age < 65, 1,
                                 ifelse(age >= 65 & age <=105, 2, NA)))
  ) %>% # end of mutate 
  # create variables
  mutate(day = as.factor(weekdays(fromdate)),
         day_admit = as.factor(weekdays(date)),
         month_smk = month(fromdate),
         month_admit = month(date),
         season_smk = ifelse(fromdate >= "2013-03-20" &  
                               fromdate <= "2013-06-21", "spring",
                             ifelse(fromdate >= "2013-06-22" &  
                                      fromdate <= "2013-09-22", "summer",
                                    ifelse(fromdate >= "2013-09-23" & 
                                             fromdate <= "2013-12-21", "fall", "other"))),
         season_admit = ifelse(date >= "2013-03-20" &  
                                 date <= "2013-06-21", "spring",
                               ifelse(date >= "2013-06-22" &  
                                        date <= "2013-09-22", "summer",
                                      ifelse(date >= "2013-09-23" & 
                                               date <= "2013-12-21", "fall", "other")))) %>%
  # join with zip-level pm estimates
  left_join(zip_smoke_w_lag, by = c("date", "ZIPCODE"))%>%
  arrange(personkey, fromdate) # order by id and fromdate

write_path4 <- paste0("../data_new/medication/oregon_ndc_time_strat_casecrossover.csv")
write_csv(outcome_casecross, write_path4)

```


## Population-Weighted PM~2.5~ Assigned by Zip Code

### Descriptives

For all of 2013, there were a total of millons of all claims records in the APAC dataset. During the May 1st to September 30th wildfire season in Oregon state, there were 24217 pharmacy visits for the beta 2 agonists with ndc. The number of persons (cases), as well as age-specific and sex-specific strate.


```{r descriptive table, echo = F, message = F, warning = F, results='asis'}
read_path6 <- paste0("../data_new/medication/oregon_ndc_time_strat_casecrossover.csv")
asthma_ndc <- read_csv(read_path6)

# dataframe list
method_list <- c('WRF-Chem Smoke', 'Geo-Weighted Smoke', 'Kriging Smoke')

# dataframe to loop through
asthma_ndc_df <- data.frame(asthma_ndc)

# outcome name
outcome_name <- "asthma"

# dataframe for analysis creation
# bind columns back together 
df_analysis <- asthma_ndc_df %>%
  filter(!is.na(wrf_smk_pm_zip)) %>% 
  # only look at outcomes
  filter(outcome == 1) %>%
  # add another row that makes sure there is a person <15 in the dataframe
  # tricking xtabs to produce a 0 cell for the outcome for age <15
  add_row(outcome = 0, age_ind = 0)
  
# cross tabs
outcome_n <- xtabs(~ outcome, df_analysis)
cross_tab_age <- xtabs(~ outcome + age_ind, df_analysis)
cross_tab_sex <- xtabs(~ outcome + sex_ind, df_analysis)
# empty matrix
point_estimates <- matrix(nrow = 1, ncol = 7, byrow = T)
  
colnames(point_estimates) <- c("outcome", "n", "age_15", "age_15_65", 
                               "age_65", "female", "male")
  
# fill in the outcome name for the dataframe before the loop
point_estimates[, 1] <- outcome_name
# fill n
point_estimates[, 2] <- outcome_n[2] # second element of the 1 dimension vector
# age <15
point_estimates[, 3] <- cross_tab_age[2, 1]
# age 15 to 65
point_estimates[, 4] <- cross_tab_age[2, 2]
# age >65
point_estimates[, 5] <- cross_tab_age[2, 3]
# male == 0
point_estimates[, 7] <- cross_tab_sex[1, 1]
# female == 1
point_estimates[, 6] <- cross_tab_sex[1, 2]


# save point estimates as a dataframe
point_est_df <- as_data_frame(point_estimates)
  
# combine each outcome dataframe itteration in to a big dataset
asthma_point_est_df <- point_est_df %>% 
  # find proportions/percents for each strata in a row
  mutate(age_15_pr = as.character(round((as.numeric(age_15)/as.numeric(n))*100,1)),
         age_15_65_pr = as.character(round((as.numeric(age_15_65)/as.numeric(n))*100,1)),
         age_65_pr = as.character(round((as.numeric(age_65)/as.numeric(n))*100,1)),
         female_pr = as.character(round((as.numeric(female)/as.numeric(n))*100,1)),
         male_pr = as.character(round((as.numeric(male)/as.numeric(n))*100,1))) %>% 
  select(outcome, n, age_15, age_15_pr, age_15_65, age_15_65_pr, age_65,
         age_65_pr, female, female_pr, male, male_pr)

# str(asthma_point_est_df)
  
tab <- htmlTable(txtRound(asthma_point_est_df, digits = 1), 
           caption = "Number of cases for each outcome observed from May 1st to September 30st, 2013",
           # column headers
           header = c("Outcome", "Cases n", "Less than 15", "(%)", "15 to 65", "(%)", "Greater than 65",
                      "(%)", "Female", "(%)", "Male", "(%)"),
           # column spanner
           cgroup = c("","Age Category", "Sex"), 
           n.cgroup = c(2, 6, 4),
           padding.rgroup = "&nbsp;&nbsp;",
           css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
           align = "llccccc" # column alignment,
            ) # end table

print(tab)


```


### Overall Age Categories


```{r time stratified age strata cdc met, warning =F, echo = F, results='asis'} 
# dataframe list

method_list <- c('WRF-Chem Smoke', 'Kriging Smoke', 'Geo-Weighted Smoke')

# dataframe to loop through
asthma_ndc_df <- data.frame(asthma_ndc)

# outcome name
outcome <- "Asthma Inhalers"
outcome_name <- "Asthma Inhalers"

# data wrangling ----
# Producing conditional logit model estimates loop 

# extract covariates from dataframe
covariates_df <- asthma_ndc_df[, c(1:26, 74:84)]
  
# extract pm values and divide by 10 and ordered
#which(colnames(df_to_loop)=="global_smk_pm_zip") # code to find column numbers
pm_estimates_df <- asthma_ndc_df[, c(87, 92, 91, 93)]/10  # create 10 unit increases

# new loop for age categories

# empty matrix (12 x 10 matrix)
point_estimates <- matrix(nrow = 3, ncol = 9, byrow = T)
    
colnames(point_estimates) <- c('outcome', 'pm_method', 'n', 'n_events', 
                                   'odds_ratio', 'lower95', 'upper95', 'se', 'p_val')    
  
# fill in the outcome namedataframe before method loop
point_estimates[, 1] <- outcome_name

# dataframe for analysis creation
# bind columns back together 
df_analysis <- cbind(covariates_df, pm_estimates_df) %>% 
  # remove missing pm values
  filter(!is.na(wrf_smk_pm_zip)) %>% 
  # the following code makes sure that the counterfactual values retained are 
  # symetric in that number of obs before = number of obs after
  mutate(obs_diff_admission = (fromdate - date)/7) 
  # dataframe is already for the entire fire season, so I don't need to subset anymore
  
# second loop to run a model for each pm estimation method
for(j in 38:40){

  # variable to model 
  var_name <- colnames(df_analysis[j])
      
  # set row number to fill
  row_n <- j-37
      
  # only run the model if the dataframe has observations
  if(nrow(df_analysis) != 0){
  # conditional logistic regression model
  mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
      
  # populate matrix
  point_estimates[row_n, 2] <- method_list[row_n]
  point_estimates[row_n, 3] <- mod$n
  point_estimates[row_n, 4] <- mod$nevent
  # odds ratio
  point_estimates[row_n, 5] <- round(exp(summary(mod)$coefficient[1,1]), 3)

  # 95% lower bound
  point_estimates[row_n, 6] <- round(exp((summary(mod)$coefficient[1,1]) -                                                                             1.96*(summary(mod)$coefficient[1,3])), 3)
  # 95% upper bound
  point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) +
                                        1.96*(summary(mod)$coefficient[1,3])), 3)
  # standard error
  point_estimates[row_n, 8] <- round(summary(mod)$coefficient[1,3], 4)
  # p val
  point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,5], 4)
      
  # create else statement that fills matrix with missing so I still have the row
  # in the final dataframe
  } else {point_estimates[row_n, 2] <- method_list[row_n]
          point_estimates[row_n, 3] <- 0
          point_estimates[row_n, 4] <- 0
          point_estimates[row_n, c(5:9)] <- 99 } # end 'if else' statement
  } # end methods loop
  
# save point estimates as a dataframe
combined_point_est_df <- as_data_frame(point_estimates)



wrf_geo_age <- combined_point_est_df %>% 
  # filter columns to just geo-smk
  # filter(pm_method == "GWR Smoke" |
    #      pm_method == "WRF-Chem Smoke") %>% 
  # subset columns I want to put in to the table
  select(2, 4:7) %>% 
  mutate(odds_ratio = ifelse(odds_ratio == 99, "--", odds_ratio),
         lower95 = ifelse(lower95 == 99, "--", lower95),
         upper95 = ifelse(upper95 == 99, "--", upper95))


tab <- htmlTable(txtRound(wrf_geo_age, digits = 3, 1:3), 
         caption = "Association between a 10 ug/m^3 in PM2.5 three smoke method and health outcomes",
         # row group by outcome
         rgroup = "Asthma",
         n.rgroup = c(rep(3, 1)), # 6 rows for each age cat for each outcome
         # column headers
         header = c("Est Method", "Events",
                    "OR&dagger;", "Lower", "Upper"),
         # column spanner
         cgroup = c("", "95% CI"), 
         n.cgroup = c(3, 2),
         padding.rgroup = "&nbsp;&nbsp;",
         css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
         align = "llcccc", # column alignment,
         tfoot="&dagger; Time-stratified: referent periods matched to events on same day of week within May to September fire season."
         ) # end table
  
print(tab)
  
combined_point_est_df_new <- combined_point_est_df %>%
  mutate(n_events_new = ifelse(as.numeric(n_events)>=100, n_events,
                        ifelse(as.numeric(n_events)<100, "0", NA))) %>%
  select(-n_events) %>%
  rename(n_events = n_events_new)


# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
wrf_geo_age_plot <- combined_point_est_df_new %>% 
  # filter columns to just geo-smk
 #  filter(pm_method == "GWR Smoke" | pm_method == "WRF-Chem Smoke") %>% 
  # do not plot results with less than 15 events, create missing vals
  # in mutate
  mutate(odds_ratio = ifelse(as.numeric(n_events) < 15, 
                             99, odds_ratio),
         lower95 = ifelse(as.numeric(n_events) < 15, 
                             99, lower95),
         upper95 = ifelse(as.numeric(n_events) < 15, 
                             99, upper95)) %>% 
  # subset columns I want to put in to the table
  select(1, 2, 9, 4:6) %>% 
  mutate(odds_ratio = ifelse(odds_ratio == 99, NA, odds_ratio),
         lower95 = ifelse(lower95 == 99, NA, lower95),
         upper95 = ifelse(upper95 == 99, NA, upper95))

# change characters to numeric and factor  
wrf_geo_age_plot$outcome <- factor(wrf_geo_age_plot$outcome,
                              levels = unique(wrf_geo_age_plot$outcome))

wrf_geo_age_plot$pm_method <- factor(wrf_geo_age_plot$pm_method,
                                levels = unique(wrf_geo_age_plot$pm_method))

wrf_geo_age_plot$n_events <- as.numeric(wrf_geo_age_plot$n_events)
wrf_geo_age_plot$odds_ratio <- as.numeric(wrf_geo_age_plot$odds_ratio)
wrf_geo_age_plot$lower95 <- as.numeric(wrf_geo_age_plot$lower95)
wrf_geo_age_plot$upper95 <- as.numeric(wrf_geo_age_plot$upper95)


## ggplot 
  print_plot <- ggplot(wrf_geo_age_plot,
    aes(x = pm_method, y = odds_ratio, color = pm_method), na.rm = T) +
    geom_point(position = position_dodge(width = 0.5), na.rm = T) + 
    geom_errorbar(aes(ymin=lower95, ymax=upper95), 
                  position = position_dodge(width = 0.5), width = 0.2, na.rm =T) +
    # custom color 
    scale_color_manual(name = "Smoke-Estimation Method", 
                       values = c("red",  "blue", "#32115C"),
                       guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
    facet_wrap(~outcome, nrow = 3, scales = "free") +
    geom_hline(yintercept = 1, linetype=2) +
    #ggtitle('Association Between PM2.5 from \n Wildfire Smoke on Hospitalizations') +
    ylab(expression(paste("Odds Ratio for 10Âµg/m"^3, " Increase in PM"[2.5]))) +
    #ylim(0, 2) +
    xlab('Smoke Estimation Method') +
    # plot theme
    theme(panel.background = element_rect(fill = 'white', colour = 'black'),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    # strip element
    strip.background = element_rect(colour=NA, fill=NA),
    panel.border = element_rect(fill = NA, color = "black"),
    # facet text size
    strip.text = element_text(size = 10),
    # axis element
    #axis.text.x = element_blank(),
    #axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.y = element_text(angle = 90),
    # legend elements
    legend.position = "bottom")
    #legend.text = element_text(size = 8))


  print(print_plot)
  # save figure
  ggsave("../plot_new/ndc_age_fig_three.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")
  
```



### Time-Stratified by Age Categories 

Following table and figure look at some outcomes stratified by age category. 

For some outcomes, like Age > 65 in WRF-Chem method, the CI is the only insignificant one in the plot.


```{r time stratified age strata cdc met, warning =F, echo = F, results='asis'} 
# dataframe list

method_list <- c('WRF-Chem Smoke', 'Kriging Smoke', 'Geo-Weighted Smoke')

# dataframe to loop through
asthma_ndc_df <- data.frame(asthma_ndc)

# outcome name
outcome <- "asthma"
outcome_name <- "Asthma"

# age category list
age_cat_list <- c(0,1,2)

# create an empty list to row bind dataframes together
datalist1 <- list()


# data wrangling ----
# Producing conditional logit model estimates loop 

# extract covariates from dataframe
covariates_df <- asthma_ndc_df[, c(1:26, 74:84)]
  
# extract pm values and divide by 10 and ordered
#which(colnames(df_to_loop)=="global_smk_pm_zip") # code to find column numbers
pm_estimates_df <- asthma_ndc_df[, c(87, 92, 91, 93)]/10  # create 10 unit increases

# new loop for age categories
for(k in 0:2){
  # empty matrix (12 x 10 matrix)
  point_estimates <- matrix(nrow = 3, ncol = 10, byrow = T)
    
  colnames(point_estimates) <- c('outcome', 'age_cat', 'pm_method', 'n', 'n_events', 
                                   'odds_ratio', 'lower95', 'upper95', 'se', 'p_val')    
  
  # fill in the outcome namedataframe before method loop
  point_estimates[, 1] <- outcome_name
  # repeat the age category 4 times for each pm method
  point_estimates[, 2] <- k
    
  # dataframe for analysis creation
  # bind columns back together 
  df_analysis <- cbind(covariates_df, pm_estimates_df) %>% 
    # remove missing pm values
    filter(!is.na(wrf_smk_pm_zip)) %>% 
    # limit to specific age category
    filter(age_ind == k) %>% 
    # the following code makes sure that the counterfactual values retained are 
    # symetric in that number of obs before = number of obs after
    mutate(obs_diff_admission = (fromdate - date)/7) 
    # dataframe is already for the entire fire season, so I don't need to subset anymore
  
  # second loop to run a model for each pm estimation method
  for(j in 38:40){

    # variable to model 
    var_name <- colnames(df_analysis[j])
      
    # set row number to fill
    row_n <- j-37
      
    # only run the model if the dataframe has observations
    if(nrow(df_analysis) != 0){
    # conditional logistic regression model
    mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
      
    # populate matrix
    point_estimates[row_n, 3] <- method_list[row_n]
    point_estimates[row_n, 4] <- mod$n
    point_estimates[row_n, 5] <- mod$nevent
    # odds ratio
    point_estimates[row_n, 6] <- round(exp(summary(mod)$coefficient[1,1]), 3)

    # 95% lower bound
    point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) -                                                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # 95% upper bound
    point_estimates[row_n, 8] <- round(exp((summary(mod)$coefficient[1,1]) +
                                        1.96*(summary(mod)$coefficient[1,3])), 3)
    # standard error
    point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,3], 4)
    # p val
    point_estimates[row_n, 10] <- round(summary(mod)$coefficient[1,5], 4)
      
    # create else statement that fills matrix with missing so I still have the row
    # in the final dataframe
    } else {point_estimates[row_n, 3] <- method_list[row_n]
            point_estimates[row_n, 4] <- 0
            point_estimates[row_n, 5] <- 0
            point_estimates[row_n, c(6:10)] <- 99 } # end 'if else' statement
    } # end methods loop
  
  # save point estimates as a dataframe
  point_est_df <- as_data_frame(point_estimates)
  datalist1[[k+1]] <- point_est_df
} # end age category loop

# bind rows of age category estimates together
combined_point_est_df <- bind_rows(datalist1)



wrf_geo_age <- combined_point_est_df %>% 
  # filter columns to just geo-smk
  # filter(pm_method == "GWR Smoke" |
    #      pm_method == "WRF-Chem Smoke") %>% 
  mutate(age_cat2 = ifelse(age_cat == 0, "Less than 15", 
                    ifelse(age_cat == 1, "15-65",
                    ifelse(age_cat == 2, "Greater than 65", NA)))) %>% 
  # subset columns I want to put in to the table
  select(3, 11, 5:8) %>% 
  mutate(odds_ratio = ifelse(odds_ratio == 99, "--", odds_ratio),
         lower95 = ifelse(lower95 == 99, "--", lower95),
         upper95 = ifelse(upper95 == 99, "--", upper95))


tab <- htmlTable(txtRound(wrf_geo_age, digits = 3, 1:3), 
         caption = "Association between a 10 ug/m^3 in PM2.5 geo smoke and health outcomes stratified by age",
         # row group by outcome
         rgroup = "Asthma",
         n.rgroup = c(rep(9, 1)), # 6 rows for each age cat for each outcome
         # column headers
         header = c("Est Method", "Age Group", "Events",
                    "OR&dagger;", "Lower", "Upper"),
         # column spanner
         cgroup = c("", "95% CI"), 
         n.cgroup = c(4, 2),
         padding.rgroup = "&nbsp;&nbsp;",
         css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
         align = "llcccc", # column alignment,
         tfoot="&dagger; Time-stratified: referent periods matched to events on same day of week within May to September fire season."
         ) # end table
  
print(tab)
  
combined_point_est_df_new <- combined_point_est_df %>%
  mutate(n_events_new = ifelse(as.numeric(n_events)>=100, n_events,
                        ifelse(as.numeric(n_events)<100, "0", NA))) %>%
  select(-n_events) %>%
  rename(n_events = n_events_new)


# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
wrf_geo_age_plot <- combined_point_est_df_new %>% 
  # filter columns to just geo-smk
 #  filter(pm_method == "GWR Smoke" | pm_method == "WRF-Chem Smoke") %>% 
  # do not plot results with less than 15 events, create missing vals
  # in mutate
  mutate(odds_ratio = ifelse(as.numeric(n_events) < 15, 
                             99, odds_ratio),
         lower95 = ifelse(as.numeric(n_events) < 15, 
                             99, lower95),
         upper95 = ifelse(as.numeric(n_events) < 15, 
                             99, upper95),
         age_cat2 = ifelse(age_cat == 0, "<15", 
                    ifelse(age_cat == 1, "15-65",
                    ifelse(age_cat == 2, ">65", NA)))) %>% 
  # subset columns I want to put in to the table
  select(1, 3, 11, 10, 5:7) %>% 
  mutate(odds_ratio = ifelse(odds_ratio == 99, NA, odds_ratio),
         lower95 = ifelse(lower95 == 99, NA, lower95),
         upper95 = ifelse(upper95 == 99, NA, upper95))

# change characters to numeric and factor  
wrf_geo_age_plot$outcome <- factor(wrf_geo_age_plot$outcome,
                              levels = unique(wrf_geo_age_plot$outcome))

wrf_geo_age_plot$pm_method <- factor(wrf_geo_age_plot$pm_method,
                                levels = unique(wrf_geo_age_plot$pm_method))

wrf_geo_age_plot$age_cat2 <- factor(wrf_geo_age_plot$age_cat2,
                                levels = unique(wrf_geo_age_plot$age_cat2))

wrf_geo_age_plot$n_events <- as.numeric(wrf_geo_age_plot$n_events)
wrf_geo_age_plot$odds_ratio <- as.numeric(wrf_geo_age_plot$odds_ratio)
wrf_geo_age_plot$lower95 <- as.numeric(wrf_geo_age_plot$lower95)
wrf_geo_age_plot$upper95 <- as.numeric(wrf_geo_age_plot$upper95)


## ggplot 
  print_plot <- ggplot(wrf_geo_age_plot,
    aes(x = age_cat2, y = odds_ratio, color = pm_method), na.rm = T) +
    geom_point(position = position_dodge(width = 0.5), na.rm = T) + 
    geom_errorbar(aes(ymin=lower95, ymax=upper95), 
                  position = position_dodge(width = 0.5), width = 0.2, na.rm =T) +
    # custom color 
    scale_color_manual(name = "Smoke-Estimation Method", 
                       values = c("red",  "blue", "#32115C"),
                       guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
    facet_wrap(~outcome, nrow = 3, scales = "free") +
    geom_hline(yintercept = 1, linetype=2) +
    #ggtitle('Association Between PM2.5 from \n Wildfire Smoke on Hospitalizations') +
    ylab(expression(paste("Odds Ratio for 10Âµg/m"^3, " Increase in PM"[2.5]))) +
    #ylim(0, 2) +
    xlab('Age Category ') +
    # plot theme
    theme(panel.background = element_rect(fill = 'white', colour = 'black'),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    # strip element
    strip.background = element_rect(colour=NA, fill=NA),
    panel.border = element_rect(fill = NA, color = "black"),
    # facet text size
    strip.text = element_text(size = 10),
    # axis element
    #axis.text.x = element_blank(),
    #axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.y = element_text(angle = 90),
    # legend elements
    legend.position = "bottom")
    #legend.text = element_text(size = 8))


  print(print_plot)
  # save figure
  ggsave("../plot_new/ndc_age_fig_three.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")
  
```


### Seasonal Time-Stratified by Sex

Association with smoke PM~2.5~ and health outcomes stratified by sex. 

All the CI do not include 1, which means the use of asthma medication (beta 2 agonists) increases about 5% when smoke increase 10 units. So the risk for getting asthma will increase about 5% ~ 8% when the smoke PM2.5 increase 10 units.

```{r sex strata cdc met adj, warning = F, echo = F, results='asis'} 
method_list <- c('WRF-Chem Smoke', 'Kriging Smoke', 'Geo-Weighted Smoke')

# dataframe to loop through
asthma_ndc_df <- data.frame(asthma_ndc)

# outcome name
outcome <- "asthma"
outcome_name <- "Asthma"

# create an empty list to row bind dataframes together
datalist1 <- list()

# sex category list
sex_strata_list <- c(0,1)

# data wrangling ----
# Producing conditional logit model estimates loop 

# extract covariates from dataframe
covariates_df <- asthma_ndc_df[, c(1:26, 74:84)]
  
# extract pm values and divide by 10 and ordered
#which(colnames(df_to_loop)=="global_smk_pm_zip") # code to find column numbers
pm_estimates_df <- asthma_ndc_df[, c(87, 92, 91, 93)]/10  # create 10 unit increases


# new loop for sex categories
for(k in 0:1){
 
  # empty matrix (12 x 10 matrix)
  point_estimates <- matrix(nrow = 3, ncol = 10, byrow = T)
    
  colnames(point_estimates) <- c('outcome', 'sex', 'pm_method', 'n', 'n_events', 
                                   'odds_ratio', 'lower95', 'upper95', 'se', 'p_val')
    
  # fill in the outcome namedataframe before method loop
  point_estimates[, 1] <- outcome_name
  # repeat the sex category 4 times for each pm method
  point_estimates[, 2] <- k
    
    
  # dataframe for analysis creation
  # bind columns back together 
  df_analysis <- cbind(covariates_df, pm_estimates_df) %>% 
    # remove missing pm values
    filter(!is.na(wrf_smk_pm_zip)) %>% 
    # limit to specific sex category
    filter(sex_ind == k) %>% 
    # the following code makes sure that the counterfactual values retained are 
    # symetric in that number of obs before = number of obs after
    mutate(obs_diff_admission = (fromdate - date)/7) 
    # dataframe is already for the entire fire season, so I don't need to subset anymore
  
  # second loop to run a model for each pm estimation method
  for(j in 38:40){

    # variable to model 
    var_name <- colnames(df_analysis[j])
      
    # set row number to fill
    row_n <- j-37
      
    # only run the model if the dataframe has observations
    if(nrow(df_analysis) != 0){
    # conditional logistic regression model
    mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
      
    # populate matrix
    point_estimates[row_n, 3] <- method_list[row_n]
    point_estimates[row_n, 4] <- mod$n
    point_estimates[row_n, 5] <- mod$nevent
    # odds ratio
    point_estimates[row_n, 6] <- round(exp(summary(mod)$coefficient[1,1]), 3)

    # 95% lower bound
    point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) -
                                      1.96*(summary(mod)$coefficient[1,3])), 3)
    # 95% upper bound
    point_estimates[row_n, 8] <- round(exp((summary(mod)$coefficient[1,1]) +
                                      1.96*(summary(mod)$coefficient[1,3])), 3)
    # standard error
    point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,3], 4)
    # p val
    point_estimates[row_n, 10] <- round(summary(mod)$coefficient[1,5], 4)
      
    # create else statement that fills matrix with missing so I still have the row
    # in the final dataframe
    } else {point_estimates[row_n, 3] <- method_list[row_n]
            point_estimates[row_n, 4] <- 0
            point_estimates[row_n, 5] <- 0
            point_estimates[row_n, c(6:10)] <- 99 } # end 'if else' statement
    } # end methods loop
  
  # save point estimates as a dataframe
  point_est_df <- as_data_frame(point_estimates)
    
  # combine previous values in dataframe that has all outcome/methods comparisons
  datalist1[[k+1]] <- point_est_df
} # end sex category loop

# bind rows of sex category estimates together
combined_point_est_df <- bind_rows(datalist1)



wrf_geo_sex <- combined_point_est_df %>% 
  # filter columns to just geo-smk
  # filter(pm_method == "GWR Smoke" | pm_method == "WRF-Chem Smoke") %>% 
  mutate(sex_cat = ifelse(sex == 0, "Male", 
               ifelse(sex == 1, "Female", NA))) %>% 
  # subset columns I want to put in to the table
  select(3, 11, 5:8)%>% 
  mutate(odds_ratio = ifelse(odds_ratio == 99, "--", odds_ratio),
         lower95 = ifelse(lower95 == 99, "--", lower95),
         upper95 = ifelse(upper95 == 99, "--", upper95))


  tab <- htmlTable(txtRound(wrf_geo_sex, digits = 3, 1:3), 
           caption = "Association between a 10 ug/m^3 in PM2.5 geo smoke and health outcomes stratified by sex",
           # row group by outcome
           rgroup = "Asthma",
           n.rgroup = c(rep(6, 1)), # 2 rows for each sex strata for each outcome
           # column headers
           header = c("Est Method", "Sex Strata", "Events",
                      "OR&dagger;", "Lower", "Upper"),
           # column spanner
           cgroup = c("", "95% CI"), 
           n.cgroup = c(4, 2),
           padding.rgroup = "&nbsp;&nbsp;",
           css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
           align = "llcccc", # column alignment,
           tfoot="&dagger; Adjusted for temperature, accounting for subject. Time-stratified: referent periods matched to events on same day of week within July to October fire season."
            ) # end table
  
  print(tab)
 
# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
wrf_geo_sex_plot <- combined_point_est_df %>% 
  # filter columns to just geo-smk
 #  filter(pm_method == "GWR Smoke" | 
   #       pm_method == "WRF-Chem Smoke") %>% 
  mutate(sex_cat = ifelse(sex == 0, "Male", 
               ifelse(sex == 1, "Female", NA))) %>%
  # subset columns I want to put in to the table
  select(1, 3, 11, 5:8) %>% 
  mutate(odds_ratio = ifelse(odds_ratio == 99, NA, odds_ratio),
         lower95 = ifelse(lower95 == 99, NA, lower95),
         upper95 = ifelse(upper95 == 99, NA, upper95))  

# change characters to numeric and factor  
wrf_geo_sex_plot$outcome <- factor(wrf_geo_sex_plot$outcome,
                              levels = unique(wrf_geo_sex_plot$outcome))

wrf_geo_sex_plot$pm_method <- factor(wrf_geo_sex_plot$pm_method,
                                levels = unique(wrf_geo_sex_plot$pm_method))

wrf_geo_sex_plot$sex_cat <- factor(wrf_geo_sex_plot$sex_cat,
                                levels = unique(wrf_geo_sex_plot$sex_cat))

wrf_geo_sex_plot$n_events <- as.numeric(wrf_geo_sex_plot$n_events)
wrf_geo_sex_plot$odds_ratio <- as.numeric(wrf_geo_sex_plot$odds_ratio)
wrf_geo_sex_plot$lower95 <- as.numeric(wrf_geo_sex_plot$lower95)
wrf_geo_sex_plot$upper95 <- as.numeric(wrf_geo_sex_plot$upper95)


## ggplot
  print_plot <- ggplot(wrf_geo_sex_plot,
    aes(x = sex_cat, y = odds_ratio, color = pm_method), na.rm = T) +
    geom_point(position = position_dodge(width = 0.5), na.rm = T) + 
    geom_errorbar(aes(ymin=lower95, ymax=upper95), 
                  position = position_dodge(width = 0.5), width = 0.2, na.rm =T) +
    # custom color 
    scale_color_manual(name = "Smoke-Estimation Method", 
                       values = c("red", "blue", "#32115C"),
                       guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
    facet_wrap(~outcome, nrow = 3, scales = "free") +
    geom_hline(yintercept = 1, linetype=2) +
    #ggtitle('Association Between PM2.5 from \n Wildfire Smoke on Hospitalizations') +
    ylab(expression(paste("Odds Ratio for 10Âµg/m"^3, " Increase in PM"[2.5]))) +
    #ylim(0, 2) +
    xlab('Sex') +
    # plot theme
    theme(panel.background = element_rect(fill = 'white', colour = 'black'),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    # strip element
    strip.background = element_rect(colour=NA, fill=NA),
    panel.border = element_rect(fill = NA, color = "black"),
    # facet text size
    strip.text = element_text(size = 10),
    # axis element
    #axis.text.x = element_blank(),
    #axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.y = element_text(angle = 90),
    # legend elements
    legend.position = "bottom")
    #legend.text = element_text(size = 8))


  print(print_plot)
  # save figure
  ggsave("../plot_new/ndc_sex_fig_three.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")


```


## County

### Time series







